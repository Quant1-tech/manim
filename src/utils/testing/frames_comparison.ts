// from _Future__ import annotations

// import functools
// import inspect
// from pathlib import Path
// from typing import Callable

// from Pytest.fixtures import FixtureRequest

// from manim import Scene
// from manim.Config import tempconfig
// from manim.Config.utils import ManimConfig
// from manim.camera.threeDCamera import ThreeDCamera
// from manim.renderer.cairoRenderer import CairoRenderer
// from manim.scene.threeDScene import ThreeDScene

// from .FramesTesters import _ControlDataWriter, _FramesTester
// from .TestClassMakers import (
//     DummySceneFileWriter,
//     MakeSceneFileWriterClass,
//     MakeTestRendererClass,
//     MakeTestSceneClass,
// )

// SCENE_PARAMETER_NAME = "scene"
// TestsRootDirPath = Path(_File__).absolute().parents[2]
// PATH_CONTROL_DATA = TestsRootDirPath / Path("controlData", "graphicalUnitsData")


// framesComparison(
//     func=None,
//     *,
//     lastFrame: bool = True,
//     rendererClass=CairoRenderer,
//     baseScene=Scene,
//     **customConfig,
// ) {
//     """Compares the frames generated by the test with control frames previously registered.

//     If there is no control frames for this test, the test will fail. To generate
//     control frames for a given test, pass ``--setTest`` flag to pytest
//     while running the test.

//     Note that this decorator can be use with or without parentheses.

//     Parameters
//     ----------
//     testName
//         The name of the test.
//     moduleName
//         The module which the test belongs to.
//     lastFrame
//         whether the test should test the last frame, by default True.
//     rendererClass
//         The base renderer to use (OpenGLRenderer/CairoRenderer), by default CairoRenderer
//     baseScene
//         The base class for the scene (ThreeDScene, etc.), by default Scene

//     .. warning::
//         By default, lastFrame is True, which means that only the last frame is tested.
//         If the scene has a moving animation, then the test must set lastFrame to False.
//     """

//     decoratorMaker(testedSceneConstruct) {
//         if (
//             SCENE_PARAMETER_NAME
//             not in inspect.getfullargspec(testedSceneConstruct).args
//         ) {
//             raise Exception(
//                 f"Invalid graphical test function test function : must have '{SCENE_PARAMETER_NAME}'as one of the parameters.",
//             )

//         # Exclude "scene" from the argument list of the signature.
//         oldSig = inspect.signature(
//             functools.partial(testedSceneConstruct, scene=None),
//         )

//         if "_ModuleTest__" not in testedSceneConstruct._Globals__:
//             raise Exception(
//                 "There is no module test name indicated for the graphical unit test. You have to declare _ModuleTest__ in the test file.",
//             )
//         moduleName = testedSceneConstruct._Globals__.get("_ModuleTest__")
//         testName = testedSceneConstruct._Name__[len("test_") :]

//         @functools.wraps(testedSceneConstruct)
//         # The "request" parameter is meant to be used as a fixture by pytest. See below.
//         wrapper(*args, request: FixtureRequest, tmpPath, **kwargs) {
//             # Wraps the testFunction to a construct method, to "freeze" the eventual additional arguments (parametrizations fixtures).
//             construct = functools.partial(testedSceneConstruct, *args, **kwargs)

//             # Kwargs contains the eventual parametrization arguments.
//             # This modify the testName so the it is defined by the parametrization arguments too.
//             # Ex : if "length" is parametrized from 0 to 20, the kwargs will be with once with {"length" : 1}, etc.
//             testNameWithParam = testName + "_".join(
//                 map(lambda tup: f"{str(tup[0])}:{str(tup[1])}", kwargs.items()),
//             )

//             configTests = ConfigTest(lastFrame)

//             configTests["textDir"] = tmpPath
//             configTests["texDir"] = tmpPath

//             if lastFrame:
//                 configTests["frameRate"] = 1
//                 configTests["dryRun"] = True

//             settingTest = request.config.getoption("--setTest")
//             try:
//                 testFilePath = testedSceneConstruct._Globals__["_File__"]
//             except Exception:
//                 testFilePath = None
//             realTest = MakeTestComparingFrames(
//                 filePath=ControlDataPath(
//                     testFilePath,
//                     moduleName,
//                     testNameWithParam,
//                     settingTest,
//                 ),
//                 baseScene=baseScene,
//                 construct=construct,
//                 rendererClass=rendererClass,
//                 isSetTestDataTest=settingTest,
//                 lastFrame=lastFrame,
//                 showDiff=request.config.getoption("--showDiff"),
//                 sizeFrame=(configTests["pixelHeight"], configTests["pixelWidth"]),
//             )

//             # Isolate the config used for the test, to avoid modifying the global config during the test run.
//             with tempconfig({**configTests, **customConfig}) {
//                 realTest()

//         parameters = list(oldSig.parameters.values())
//         # Adds "request" param into the signature of the wrapper, to use the associated pytest fixture.
//         # This fixture is needed to have access to flags value and pytest's config. See above.
//         if "request" not in oldSig.parameters:
//             parameters += [inspect.Parameter("request", inspect.Parameter.KEYWORD_ONLY)]
//         if "tmpPath" not in oldSig.parameters:
//             parameters += [
//                 inspect.Parameter("tmpPath", inspect.Parameter.KEYWORD_ONLY),
//             ]
//         newSig = oldSig.replace(parameters=parameters)
//         wrapper._Signature__ = newSig

//         # Reach a bit into pytest internals to hoist the marks from our wrapped
//         # function.
//         setattr(wrapper, "pytestmark", [])
//         newMarks = getattr(testedSceneConstruct, "pytestmark", [])
//         wrapper.pytestmark = newMarks
//         return wrapper

//     # Case where the decorator is called with and without parentheses.
//     # If func is None, callabl(None) returns False
//     if callable(func) {
//         return decoratorMaker(func)
//     return decoratorMaker


// MakeTestComparingFrames(
//     filePath: Path,
//     baseScene: type[Scene],
//     construct: Callable[[Scene], None],
//     rendererClass,  # Renderer type, there is no superclass renderer yet .....
//     isSetTestDataTest: bool,
//     lastFrame: bool,
//     showDiff: bool,
//     sizeFrame: tuple,
// ) -> Callable[[], None]:
//     """Create the real pytest test that will fail if the frames mismatch.

//     Parameters
//     ----------
//     filePath : Path
//         The path of the control frames.
//     baseScene : Type[Scene]
//         The base scene class.
//     construct : Callable[[Scene], None]
//         The construct method (= the test function)
//     rendererClass : [type]
//         The renderer base class.
//     showDiff : bool
//         whether to visually showDiff (see --showDiff)

//     Returns
//     -------
//     Callable[[], None]
//         The pytest test.
//     """

//     if isSetTestDataTest:
//         framesTester = _ControlDataWriter(filePath, sizeFrame=sizeFrame)
//     else:
//         framesTester = _FramesTester(filePath, showDiff=showDiff)

//     fileWriterClass = (
//         MakeSceneFileWriterClass(framesTester)
//         if not lastFrame
//         else DummySceneFileWriter
//     )
//     testRenderer = MakeTestRendererClass(rendererClass)

//     realTest() {
//         with framesTester.testing() {
//             sceneTested = MakeTestSceneClass(
//                 baseScene=baseScene,
//                 constructTest=construct,
//                 # NOTE this is really ugly but it's due to the very bad design of the two renderers.
//                 # If you pass a custom renderer to the Scene, the Camera class given as an argument in the Scene
//                 # is not passed to the renderer. See _Init__ of Scene.
//                 # This potentially prevents OpenGL testing.
//                 testRenderer=testRenderer(fileWriterClass=fileWriterClass)
//                 if baseScene is not ThreeDScene
//                 else testRenderer(
//                     fileWriterClass=fileWriterClass,
//                     cameraClass=ThreeDCamera,
//                 ),  # testRenderer(fileWriterClass=fileWriterClass),
//             )
//             sceneTested = sceneTested(skipAnimations=True)
//             sceneTested.render()
//             if lastFrame:
//                 framesTester.checkFrame(-1, sceneTested.renderer.getFrame())

//     return realTest


// ControlDataPath(
//     testFilePath: str | None, moduleName: str, testName: str, settingTest: bool
// ) -> Path:
//     if testFilePath is None:
//         # For some reason, path to test file containing @framesComparison could not
//         # be determined. Use local directory instead.
//         testFilePath = _File__

//     path = Path(testFilePath).absolute().parent / "controlData" / moduleName

//     if settingTest:
//         # Create the directory if not existing.
//         path.mkdir(existOk=True)
//     if not settingTest and not path.exists() {
//         raise Exception(f"The control frames directory can't be found  in {path}")
//     path = (path / testName).withSuffix(".npz")
//     if not settingTest and not path.isFile() {
//         raise Exception(
//             f"The control frame for the test {testName} cannot be found in {path.parent}. "
//             "Make sure you generated the control frames first.",
//         )
//     return path


// ConfigTest(lastFrame: bool) -> ManimConfig:
//     return ManimConfig().digestFile(
//         str(
//             Path(_File__).parent
//             / (
//                 "configGraphicalTestsMonoframe.cfg"
//                 if lastFrame
//                 else "configGraphicalTestsMultiframes.cfg"
//             ),
//         ),
//     )
