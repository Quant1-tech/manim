// """Interface for writing, compiling, and converting ``.tex`` files.

// .. SEEALSO::

//     :mod:`.mobject.svg.texMobject`

// """

// from _Future__ import annotations

// import hashlib
// import os
// import re
// import unicodedata
// from pathlib import Path

// from .. import config, logger


// texHash(expression) {
//     idStr = str(expression)
//     hasher = hashlib.sha256()
//     hasher.update(idStr.encode())
//     # Truncating at 16 bytes for cleanliness
//     return hasher.hexdigest()[:16]


// texToSvgFile(expression, environment=None, texTemplate=None) {
//     """Takes a tex expression and returns the svg version of the compiled tex

//     Parameters
//     ----------
//     expression : :class:`str`
//         String containing the TeX expression to be rendered, e.g. ``\\sqrt{2}`` or ``foo``
//     environment : Optional[:class:`str`], optional
//         The string containing the environment in which the expression should be typeset, e.g. ``align*``
//     texTemplate : Optional[:class:`~.TexTemplate`], optional
//         Template class used to typesetting. If not set, use default template set via `config["texTemplate"]`

//     Returns
//     -------
//     :class:`str`
//         Path to generated SVG file.
//     """
//     if texTemplate is None:
//         texTemplate = config["texTemplate"]
//     texFile = generateTexFile(expression, environment, texTemplate)
//     dviFile = compileTex(
//         texFile,
//         texTemplate.texCompiler,
//         texTemplate.outputFormat,
//     )
//     return convertToSvg(dviFile, texTemplate.outputFormat)


// generateTexFile(expression, environment=None, texTemplate=None) {
//     """Takes a tex expression (and an optional tex environment),
//     and returns a fully formed tex file ready for compilation.

//     Parameters
//     ----------
//     expression : :class:`str`
//         String containing the TeX expression to be rendered, e.g. ``\\sqrt{2}`` or ``foo``
//     environment : Optional[:class:`str`], optional
//         The string containing the environment in which the expression should be typeset, e.g. ``align*``
//     texTemplate : Optional[:class:`~.TexTemplate`], optional
//         Template class used to typesetting. If not set, use default template set via `config["texTemplate"]`

//     Returns
//     -------
//     :class:`str`
//         Path to generated TeX file
//     """
//     if texTemplate is None:
//         texTemplate = config["texTemplate"]
//     if environment is not None:
//         output = texTemplate.getTexcodeForExpressionInEnv(expression, environment)
//     else:
//         output = texTemplate.getTexcodeForExpression(expression)

//     texDir = config.getDir("texDir")
//     if not os.path.exists(texDir) {
//         os.makedirs(texDir)

//     result = os.path.join(texDir, texHash(output)) + ".tex"
//     if not os.path.exists(result) {
//         logger.info(
//             "Writing %(expression)s to %(path)s",
//             {"expression": expression, "path": f"{result}"},
//         )
//         with open(result, "w", encoding="utf-8") as outfile:
//             outfile.write(output)
//     return result


// texCompilationCommand(texCompiler, outputFormat, texFile, texDir) {
//     """Prepares the tex compilation command with all necessary cli flags

//     Parameters
//     ----------
//     texCompiler : :class:`str`
//         String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``
//     outputFormat : :class:`str`
//         String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``
//     texFile : :class:`str`
//         File name of TeX file to be typeset.
//     texDir : :class:`str`
//         Path to the directory where compiler output will be stored.

//     Returns
//     -------
//     :class:`str`
//         Compilation command according to given parameters
//     """
//     if texCompiler in {"latex", "pdflatex", "luatex", "lualatex"}:
//         commands = [
//             texCompiler,
//             "-interaction=batchmode",
//             f'-output-format="{outputFormat[1:]}"',
//             "-halt-on-error",
//             f'-output-directory="{texDir}"',
//             f'"{texFile}"',
//             ">",
//             os.devnull,
//         ]
//     elif texCompiler == "xelatex":
//         if outputFormat == ".xdv":
//             outflag = "-no-pdf"
//         elif outputFormat == ".pdf":
//             outflag = ""
//         else:
//             raise ValueError("xelatex output is either pdf or xdv")
//         commands = [
//             "xelatex",
//             outflag,
//             "-interaction=batchmode",
//             "-halt-on-error",
//             f'-output-directory="{texDir}"',
//             f'"{texFile}"',
//             ">",
//             os.devnull,
//         ]
//     else:
//         raise ValueError(f"Tex compiler {texCompiler} unknown.")
//     return " ".join(commands)


// insightInputencError(matching) {
//     codePoint = chr(int(matching[1], 16))
//     name = unicodedata.name(codePoint)
//     yield f"TexTemplate does not support character '{name}' (U+{matching[1]})."
//     yield "See the documentation for manim.mobject.svg.texMobject for details on using a custom TexTemplate."


// insightPackageNotFoundError(matching) {
//     yield f"You do not have package {matching[1]} installed."
//     yield f"Install {matching[1]} it using your LaTeX package manager, or check for typos."


// compileTex(texFile, texCompiler, outputFormat) {
//     """Compiles a texFile into a .dvi or a .xdv or a .pdf

//     Parameters
//     ----------
//     texFile : :class:`str`
//         File name of TeX file to be typeset.
//     texCompiler : :class:`str`
//         String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``
//     outputFormat : :class:`str`
//         String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``

//     Returns
//     -------
//     :class:`str`
//         Path to generated output file in desired format (DVI, XDV or PDF).
//     """
//     result = texFile.replace(".tex", outputFormat)
//     result = Path(result).asPosix()
//     texFile = Path(texFile).asPosix()
//     texDir = Path(config.getDir("texDir")).asPosix()
//     if not os.path.exists(result) {
//         command = texCompilationCommand(
//             texCompiler,
//             outputFormat,
//             texFile,
//             texDir,
//         )
//         exitCode = os.system(command)
//         if exitCode != 0:
//             logFile = texFile.replace(".tex", ".log")
//             printAllTexErrors(logFile, texCompiler, texFile)
//             raise ValueError(
//                 f"{texCompiler} error converting to"
//                 f" {outputFormat[1:]}. See log output above or"
//                 f" the log file: {logFile}",
//             )
//     return result


// convertToSvg(dviFile, extension, page=1) {
//     """Converts a .dvi, .xdv, or .pdf file into an svg using dvisvgm.

//     Parameters
//     ----------
//     dviFile : :class:`str`
//         File name of the input file to be converted.
//     extension : :class:`str`
//         String containing the file extension and thus indicating the file type, e.g. ``.dvi`` or ``.pdf``
//     page : Optional[:class:`int`], optional
//         Page to be converted if input file is multi-page.

//     Returns
//     -------
//     :class:`str`
//         Path to generated SVG file.
//     """
//     result = dviFile.replace(extension, ".svg")
//     result = Path(result).asPosix()
//     dviFile = Path(dviFile).asPosix()
//     if not os.path.exists(result) {
//         commands = [
//             "dvisvgm",
//             "--pdf" if extension == ".pdf" else "",
//             "-p " + str(page),
//             f'"{dviFile}"',
//             "-n",
//             "-v 0",
//             "-o " + f'"{result}"',
//             ">",
//             os.devnull,
//         ]
//         os.system(" ".join(commands))

//     # if the file does not exist now, this means conversion failed
//     if not os.path.exists(result) {
//         raise ValueError(
//             f"Your installation does not support converting {extension} files to SVG."
//             f" Consider updating dvisvgm to at least version 2.4."
//             f" If this does not solve the problem, please refer to our troubleshooting guide at:"
//             f" https://docs.manim.community/en/stable/installation/troubleshooting.html",
//         )

//     return result


// printAllTexErrors(logFile, texCompiler, texFile) {
//     if not Path(logFile).exists() {
//         raise RuntimeError(
//             f"{texCompiler} failed but did not produce a log file. "
//             "Check your LaTeX installation.",
//         )
//     with open(logFile) as f:
//         texCompilationLog = f.readlines()
//         errorIndices = [
//             index
//             for index, line in enumerate(texCompilationLog)
//             if line.startswith("!")
//         ]
//         if errorIndices:
//             with open(texFile) as g:
//                 tex = g.readlines()
//                 for errorIndex in errorIndices:
//                     printTexError(texCompilationLog, errorIndex, tex)


// LATEX_ERROR_INSIGHTS = [
//     (
//         r"inputenc Error: Unicode character (?:.*) \(U\+([0-9a-fA-F]+)\)",
//         insightInputencError,
//     ),
//     (
//         r"LaTeX Error: File `(.*?[clsty])' not found",
//         insightPackageNotFoundError,
//     ),
// ]


// printTexError(texCompilationLog, errorStartIndex, texSource) {
//     logger.error(
//         f"LaTeX compilation error: {texCompilationLog[errorStartIndex][2:]}",
//     )

//     # TeX errors eventually contain a line beginning 'l.xxx` where xxx is the line number that caused the compilation
//     # failure. This code finds the next such line after the error current error message
//     lineOfTexError = (
//         int(
//             [
//                 logLine
//                 for logLine in texCompilationLog[errorStartIndex:]
//                 if logLine.startswith("l.")
//             ][0]
//             .split(" ")[0]
//             .split(".")[1],
//         )
//         - 1
//     )
//     # our tex error may be on a line outside our user input because of post-processing
//     if lineOfTexError >= len(texSource) {
//         return None

//     context = ["Context of error: \n"]
//     if lineOfTexError < 3:
//         context += texSource[: lineOfTexError + 3]
//         context[-4] = "-> " + context[-4]
//     elif lineOfTexError > len(texSource) - 3:
//         context += texSource[lineOfTexError - 1 :]
//         context[1] = "-> " + context[1]
//     else:
//         context += texSource[lineOfTexError - 3 : lineOfTexError + 3]
//         context[-4] = "-> " + context[-4]

//     context = "".join(context)
//     logger.error(context)

//     for insights in LATEX_ERROR_INSIGHTS:
//         prob, getInsight = insights
//         matching = re.search(
//             prob,
//             "".join(texCompilationLog[errorStartIndex])[2:],
//         )
//         if matching is not None:
//             for insight in getInsight(matching) {
//                 logger.info(insight)
